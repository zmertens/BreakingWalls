#include "LoadingState.hpp"

#include <SDL3/SDL.h>

#include <MazeBuilder/io_utils.h>
#include <MazeBuilder/create2.h>
#include <MazeBuilder/configurator.h>

#include "JsonUtils.hpp"
#include "MazeLayout.hpp"
#include "ResourceIdentifiers.hpp"
#include "ResourceManager.hpp"
#include "StateStack.hpp"
#include "Texture.hpp"

/// @brief
/// @param stack
/// @param context
/// @param resourcePath ""
LoadingState::LoadingState(StateStack& stack, Context context, std::string_view resourcePath)
    : State(stack, context)
      , mLoadingSprite{context.textures->get(Textures::ID::LEVEL_ONE)}
      , mForeman{}
      , mHasFinished{false}
      , mResourcePath{resourcePath}
{
    mForeman.initThreads();

    // Start loading resources in background if path is provided
    if (!mResourcePath.empty())
    {
        loadResources();
    }
    else
    {
        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "LoadingState: No resource path provided: %s\n",
                    mResourcePath.data());
        mHasFinished = true;
    }
}

void LoadingState::draw() const noexcept
{
    const auto& window = *getContext().window;

    window.draw(mLoadingSprite);
}

bool LoadingState::update(float dt, unsigned int subSteps) noexcept
{
    if (!mHasFinished && mForeman.isDone())
    {
        // Loading is complete - get the loaded resources
        const auto resources = mForeman.getResources();
        SDL_Log("Loading complete! Loaded %zu resources. Loading textures...\n", resources.size());

        // Now actually load the textures from the worker-collected texture requests
        loadTexturesFromWorkerRequests();

        // Load composed maze textures from level_defaults
        loadMazeTexturesFromComposedStrings();

        // Handle window icon separately (special case, not managed by TextureManager)
        loadWindowIcon(resources);

        mHasFinished = true;
        SDL_Log("All textures loaded! Press any key to continue...\n");
    }

    if (!mHasFinished)
    {
        setCompletion(mForeman.getCompletion());
    }

    return true;
}

bool LoadingState::handleEvent(const SDL_Event& event) noexcept
{
    return true;
}

void LoadingState::setCompletion(float percent) noexcept
{
    if (percent > 1.f)
    {
        percent = 1.f;
    }

    // Update loading sprite or progress bar based on percent
    SDL_Log("Loading progress: %.2f%%", percent * 100.f);
}

bool LoadingState::isFinished() const noexcept { return mHasFinished; }

/// @brief Load resources from the specified path
/// @param resourcePath Path to the JSON resource configuration
void LoadingState::loadResources() noexcept
{
    SDL_Log("LoadingState::loadResources - Loading from: %s\n", mResourcePath.data());

    // This would be called by the application to trigger resource loading
    // The resources would be loaded by the worker threads and stored
    mForeman.generate(mResourcePath);
}

void LoadingState::loadTexturesFromWorkerRequests() const noexcept
{
    auto& textures = *getContext().textures;
    auto* renderer = getContext().window->getRenderer();

    // Get the texture load requests that were collected by worker threads
    auto textureRequests = mForeman.getTextureLoadRequests();

    SDL_Log("Loading %zu textures on main thread...\n", textureRequests.size());

    try
    {
        for (const auto& request : textureRequests)
        {
            textures.load(renderer, request.id, request.path);
            SDL_Log("DEBUG: Loaded texture ID %d from: %s\n", static_cast<int>(request.id), request.path.c_str());
        }
    }
    catch (const std::exception& e)
    {
        SDL_LogError(SDL_LOG_CATEGORY_ERROR, "Failed to load textures: %s\n", e.what());
    }
}

void LoadingState::loadMazeTexturesFromComposedStrings() const noexcept
{
    auto& textures = *getContext().textures;
    auto* renderer = getContext().window->getRenderer();

    // Get the composed maze strings that were generated by worker threads
    auto composedMazes = mForeman.getComposedMazeStrings();

    SDL_Log("Loading %zu maze textures using MazeBuilder pixels API...\n", composedMazes.size());

    try
    {
        for (const auto& [id, mazeString] : composedMazes)
        {
            // Parse the maze string to create a grid for pixel generation
            const size_t rows = std::count(mazeString.begin(), mazeString.end(), '\n');
            
            if (rows == 0)
            {
                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Maze string has no newlines, skipping");
                continue;
            }
            
            // Use create2 to parse the ASCII maze string into a grid
            // create2 returns std::string, not a grid pointer - we need to use the maze string directly
            // Instead, let's just use the old method but with better cell sizing
            
            // Calculate appropriate cell size based on maze dimensions
            // Use 8-12 pixel cells like the working physics_game example
            // This makes the physics scale more manageable
            const int targetCellSize = 10;  // Smaller cells work better with Box2D scale
            
            MazeLayout maze = MazeLayout::fromString(mazeString, targetCellSize);
            
            if (maze.getPixelWidth() > 0 && maze.getPixelHeight() > 0)
            {
                textures.load(renderer, id, maze);
                SDL_Log("DEBUG: Loaded maze texture ID %d (%dx%d pixels, %d cell size)\n",
                        static_cast<int>(id), maze.getPixelWidth(), maze.getPixelHeight(), targetCellSize);
            }
            else
            {
                SDL_LogError(SDL_LOG_CATEGORY_ERROR, "Generated maze has invalid dimensions for ID %d", static_cast<int>(id));
            }
        }
    }
    catch (const std::exception& e)
    {
        SDL_LogError(SDL_LOG_CATEGORY_ERROR, "Failed to load maze textures: %s\n", e.what());
    }
}

void LoadingState::loadWindowIcon(const std::unordered_map<std::string, std::string>& resources) noexcept
{
    using std::string;

    JSONUtils jsonUtils{};
    auto resourcePathPrefix = mazes::io_utils::getDirectoryPath(mResourcePath) + "/";

    // Window icon is special case, no need to save the texture in the manager
    if (auto windowIconKey = resources.find(string{JSONKeys::WINDOW_ICON}); windowIconKey != resources.cend())
    {
        string windowIconPath = resourcePathPrefix + JSONUtils::extractJsonValue(windowIconKey->second);

        if (SDL_Surface* icon = SDL_LoadBMP(windowIconPath.c_str()); icon != nullptr)
        {
            if (auto* renderWindow = getContext().window; renderWindow != nullptr)
            {
                SDL_SetWindowIcon(renderWindow->getSDLWindow(), icon);
                SDL_DestroySurface(icon);
                SDL_Log("DEBUG: Loading window icon from: %s\n", windowIconPath.c_str());
            }
        }
        else
        {
            SDL_LogError(SDL_LOG_CATEGORY_ERROR, "Failed to load icon: %s - %s\n", windowIconPath.c_str(),
                         SDL_GetError());
        }
    }
}
